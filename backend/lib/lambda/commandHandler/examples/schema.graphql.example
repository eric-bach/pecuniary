type Event {
  id: ID!
  aggregateId: ID!
  name: String!
  version: Int!
  data: String!
  userId: ID!
  createdAt: AWSDateTime!
}

type AccountType {
  id: ID!
  name: String!
  description: String
  accounts(filter: ModelAccountReadModelFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelAccountReadModelConnection
}

type TransactionType {
  id: ID!
  name: String!
  description: String!
  transactions(filter: ModelTransactionReadModelFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelTransactionReadModelConnection
}

type CurrencyType {
  id: ID!
  name: String!
  description: String!
  exchangeTypes(filter: ModelExchangeTypeFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelExchangeTypeConnection
}

type ExchangeType {
  id: ID!
  name: String!
  description: String!
  currencyType: CurrencyType!
}

type AccountReadModel {
  id: ID!
  aggregateId: ID!
  version: Int!
  userId: ID!
  name: String!
  description: String
  bookValue: Float!
  marketValue: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  accountType: AccountType!
  transactions(filter: ModelTransactionReadModelFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelTransactionReadModelConnection
  positions(filter: ModelPositionReadModelFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelPositionReadModelConnection
}

type TransactionReadModel {
  id: ID!
  aggregateId: ID!
  version: Int!
  userId: ID!
  transactionDate: AWSDate!
  shares: Int!
  price: Float!
  commission: Float!
  symbol: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  account: AccountReadModel!
  transactionType: TransactionType!
}

type PositionReadModel {
  id: ID!
  aggregateId: ID!
  version: Int!
  userId: ID!
  symbol: String!
  name: String!
  shares: Int!
  acb: Float!
  bookValue: Float!
  marketValue: Float!
  type: String!
  region: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  account: AccountReadModel!
}

type TimeSeries {
  id: ID!
  symbol: String!
  name: String!
  type: String!
  region: String!
  currency: String!
  date: AWSDate!
  open: Float!
  high: Float!
  low: Float!
  close: Float!
  volume: Int!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelEventConnection {
  items: [Event]
  nextToken: String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelEventFilterInput {
  id: ModelIDInput
  aggregateId: ModelIDInput
  name: ModelStringInput
  version: ModelIntInput
  data: ModelStringInput
  userId: ModelIDInput
  createdAt: ModelStringInput
  and: [ModelEventFilterInput]
  or: [ModelEventFilterInput]
  not: ModelEventFilterInput
}

type Query {
  getEvent(id: ID!): Event
  listEvents(filter: ModelEventFilterInput, limit: Int, nextToken: String): ModelEventConnection
  getAccountType(id: ID!): AccountType
  listAccountTypes(filter: ModelAccountTypeFilterInput, limit: Int, nextToken: String): ModelAccountTypeConnection
  getTransactionType(id: ID!): TransactionType
  listTransactionTypes(filter: ModelTransactionTypeFilterInput, limit: Int, nextToken: String): ModelTransactionTypeConnection
  getCurrencyType(id: ID!): CurrencyType
  listCurrencyTypes(filter: ModelCurrencyTypeFilterInput, limit: Int, nextToken: String): ModelCurrencyTypeConnection
  getExchangeType(id: ID!): ExchangeType
  listExchangeTypes(filter: ModelExchangeTypeFilterInput, limit: Int, nextToken: String): ModelExchangeTypeConnection
  getAccountReadModel(id: ID!): AccountReadModel
  listAccountReadModels(filter: ModelAccountReadModelFilterInput, limit: Int, nextToken: String): ModelAccountReadModelConnection
  getTransactionReadModel(id: ID!): TransactionReadModel
  listTransactionReadModels(filter: ModelTransactionReadModelFilterInput, limit: Int, nextToken: String): ModelTransactionReadModelConnection
  getPositionReadModel(id: ID!): PositionReadModel
  listPositionReadModels(filter: ModelPositionReadModelFilterInput, limit: Int, nextToken: String): ModelPositionReadModelConnection
  getTimeSeries(id: ID!): TimeSeries
  listTimeSeriess(filter: ModelTimeSeriesFilterInput, limit: Int, nextToken: String): ModelTimeSeriesConnection
}

input CreateEventInput {
  id: ID
  aggregateId: ID!
  name: String!
  version: Int!
  data: String!
  userId: ID!
  createdAt: AWSDateTime!
}

input UpdateEventInput {
  id: ID!
  aggregateId: ID
  name: String
  version: Int
  data: String
  userId: ID
  createdAt: AWSDateTime
}

input DeleteEventInput {
  id: ID
}

type Mutation {
  createEvent(input: CreateEventInput!, condition: ModelEventConditionInput): Event
  updateEvent(input: UpdateEventInput!, condition: ModelEventConditionInput): Event
  deleteEvent(input: DeleteEventInput!, condition: ModelEventConditionInput): Event
  createAccountType(input: CreateAccountTypeInput!, condition: ModelAccountTypeConditionInput): AccountType
  updateAccountType(input: UpdateAccountTypeInput!, condition: ModelAccountTypeConditionInput): AccountType
  deleteAccountType(input: DeleteAccountTypeInput!, condition: ModelAccountTypeConditionInput): AccountType
  createTransactionType(input: CreateTransactionTypeInput!, condition: ModelTransactionTypeConditionInput): TransactionType
  updateTransactionType(input: UpdateTransactionTypeInput!, condition: ModelTransactionTypeConditionInput): TransactionType
  deleteTransactionType(input: DeleteTransactionTypeInput!, condition: ModelTransactionTypeConditionInput): TransactionType
  createCurrencyType(input: CreateCurrencyTypeInput!, condition: ModelCurrencyTypeConditionInput): CurrencyType
  updateCurrencyType(input: UpdateCurrencyTypeInput!, condition: ModelCurrencyTypeConditionInput): CurrencyType
  deleteCurrencyType(input: DeleteCurrencyTypeInput!, condition: ModelCurrencyTypeConditionInput): CurrencyType
  createExchangeType(input: CreateExchangeTypeInput!, condition: ModelExchangeTypeConditionInput): ExchangeType
  updateExchangeType(input: UpdateExchangeTypeInput!, condition: ModelExchangeTypeConditionInput): ExchangeType
  deleteExchangeType(input: DeleteExchangeTypeInput!, condition: ModelExchangeTypeConditionInput): ExchangeType
  createAccountReadModel(input: CreateAccountReadModelInput!, condition: ModelAccountReadModelConditionInput): AccountReadModel
  updateAccountReadModel(input: UpdateAccountReadModelInput!, condition: ModelAccountReadModelConditionInput): AccountReadModel
  deleteAccountReadModel(input: DeleteAccountReadModelInput!, condition: ModelAccountReadModelConditionInput): AccountReadModel
  createTransactionReadModel(input: CreateTransactionReadModelInput!, condition: ModelTransactionReadModelConditionInput): TransactionReadModel
  updateTransactionReadModel(input: UpdateTransactionReadModelInput!, condition: ModelTransactionReadModelConditionInput): TransactionReadModel
  deleteTransactionReadModel(input: DeleteTransactionReadModelInput!, condition: ModelTransactionReadModelConditionInput): TransactionReadModel
  createPositionReadModel(input: CreatePositionReadModelInput!, condition: ModelPositionReadModelConditionInput): PositionReadModel
  updatePositionReadModel(input: UpdatePositionReadModelInput!, condition: ModelPositionReadModelConditionInput): PositionReadModel
  deletePositionReadModel(input: DeletePositionReadModelInput!, condition: ModelPositionReadModelConditionInput): PositionReadModel
  createTimeSeries(input: CreateTimeSeriesInput!, condition: ModelTimeSeriesConditionInput): TimeSeries
  updateTimeSeries(input: UpdateTimeSeriesInput!, condition: ModelTimeSeriesConditionInput): TimeSeries
  deleteTimeSeries(input: DeleteTimeSeriesInput!, condition: ModelTimeSeriesConditionInput): TimeSeries
}

input ModelEventConditionInput {
  aggregateId: ModelIDInput
  name: ModelStringInput
  version: ModelIntInput
  data: ModelStringInput
  userId: ModelIDInput
  createdAt: ModelStringInput
  and: [ModelEventConditionInput]
  or: [ModelEventConditionInput]
  not: ModelEventConditionInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

type Subscription {
  onCreateEvent: Event @aws_subscribe(mutations: ["createEvent"])
  onUpdateEvent: Event @aws_subscribe(mutations: ["updateEvent"])
  onDeleteEvent: Event @aws_subscribe(mutations: ["deleteEvent"])
  onCreateAccountType: AccountType @aws_subscribe(mutations: ["createAccountType"])
  onUpdateAccountType: AccountType @aws_subscribe(mutations: ["updateAccountType"])
  onDeleteAccountType: AccountType @aws_subscribe(mutations: ["deleteAccountType"])
  onCreateTransactionType: TransactionType @aws_subscribe(mutations: ["createTransactionType"])
  onUpdateTransactionType: TransactionType @aws_subscribe(mutations: ["updateTransactionType"])
  onDeleteTransactionType: TransactionType @aws_subscribe(mutations: ["deleteTransactionType"])
  onCreateCurrencyType: CurrencyType @aws_subscribe(mutations: ["createCurrencyType"])
  onUpdateCurrencyType: CurrencyType @aws_subscribe(mutations: ["updateCurrencyType"])
  onDeleteCurrencyType: CurrencyType @aws_subscribe(mutations: ["deleteCurrencyType"])
  onCreateExchangeType: ExchangeType @aws_subscribe(mutations: ["createExchangeType"])
  onUpdateExchangeType: ExchangeType @aws_subscribe(mutations: ["updateExchangeType"])
  onDeleteExchangeType: ExchangeType @aws_subscribe(mutations: ["deleteExchangeType"])
  onCreateAccountReadModel: AccountReadModel @aws_subscribe(mutations: ["createAccountReadModel"])
  onUpdateAccountReadModel: AccountReadModel @aws_subscribe(mutations: ["updateAccountReadModel"])
  onDeleteAccountReadModel: AccountReadModel @aws_subscribe(mutations: ["deleteAccountReadModel"])
  onCreateTransactionReadModel: TransactionReadModel @aws_subscribe(mutations: ["createTransactionReadModel"])
  onUpdateTransactionReadModel: TransactionReadModel @aws_subscribe(mutations: ["updateTransactionReadModel"])
  onDeleteTransactionReadModel: TransactionReadModel @aws_subscribe(mutations: ["deleteTransactionReadModel"])
  onCreatePositionReadModel: PositionReadModel @aws_subscribe(mutations: ["createPositionReadModel"])
  onUpdatePositionReadModel: PositionReadModel @aws_subscribe(mutations: ["updatePositionReadModel"])
  onDeletePositionReadModel: PositionReadModel @aws_subscribe(mutations: ["deletePositionReadModel"])
  onCreateTimeSeries: TimeSeries @aws_subscribe(mutations: ["createTimeSeries"])
  onUpdateTimeSeries: TimeSeries @aws_subscribe(mutations: ["updateTimeSeries"])
  onDeleteTimeSeries: TimeSeries @aws_subscribe(mutations: ["deleteTimeSeries"])
}

type ModelAccountTypeConnection {
  items: [AccountType]
  nextToken: String
}

input ModelAccountTypeFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelAccountTypeFilterInput]
  or: [ModelAccountTypeFilterInput]
  not: ModelAccountTypeFilterInput
}

input CreateAccountTypeInput {
  id: ID
  name: String!
  description: String
}

input UpdateAccountTypeInput {
  id: ID!
  name: String
  description: String
}

input DeleteAccountTypeInput {
  id: ID
}

input ModelAccountTypeConditionInput {
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelAccountTypeConditionInput]
  or: [ModelAccountTypeConditionInput]
  not: ModelAccountTypeConditionInput
}

type ModelTransactionTypeConnection {
  items: [TransactionType]
  nextToken: String
}

input ModelTransactionTypeFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelTransactionTypeFilterInput]
  or: [ModelTransactionTypeFilterInput]
  not: ModelTransactionTypeFilterInput
}

input CreateTransactionTypeInput {
  id: ID
  name: String!
  description: String!
}

input UpdateTransactionTypeInput {
  id: ID!
  name: String
  description: String
}

input DeleteTransactionTypeInput {
  id: ID
}

input ModelTransactionTypeConditionInput {
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelTransactionTypeConditionInput]
  or: [ModelTransactionTypeConditionInput]
  not: ModelTransactionTypeConditionInput
}

type ModelCurrencyTypeConnection {
  items: [CurrencyType]
  nextToken: String
}

input ModelCurrencyTypeFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelCurrencyTypeFilterInput]
  or: [ModelCurrencyTypeFilterInput]
  not: ModelCurrencyTypeFilterInput
}

input CreateCurrencyTypeInput {
  id: ID
  name: String!
  description: String!
}

input UpdateCurrencyTypeInput {
  id: ID!
  name: String
  description: String
}

input DeleteCurrencyTypeInput {
  id: ID
}

input ModelCurrencyTypeConditionInput {
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelCurrencyTypeConditionInput]
  or: [ModelCurrencyTypeConditionInput]
  not: ModelCurrencyTypeConditionInput
}

type ModelExchangeTypeConnection {
  items: [ExchangeType]
  nextToken: String
}

input ModelExchangeTypeFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelExchangeTypeFilterInput]
  or: [ModelExchangeTypeFilterInput]
  not: ModelExchangeTypeFilterInput
}

input CreateExchangeTypeInput {
  id: ID
  name: String!
  description: String!
  exchangeTypeCurrencyTypeId: ID!
}

input UpdateExchangeTypeInput {
  id: ID!
  name: String
  description: String
  exchangeTypeCurrencyTypeId: ID
}

input DeleteExchangeTypeInput {
  id: ID
}

input ModelExchangeTypeConditionInput {
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelExchangeTypeConditionInput]
  or: [ModelExchangeTypeConditionInput]
  not: ModelExchangeTypeConditionInput
}

type ModelAccountReadModelConnection {
  items: [AccountReadModel]
  nextToken: String
}

input ModelAccountReadModelFilterInput {
  id: ModelIDInput
  aggregateId: ModelIDInput
  version: ModelIntInput
  userId: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  bookValue: ModelFloatInput
  marketValue: ModelFloatInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelAccountReadModelFilterInput]
  or: [ModelAccountReadModelFilterInput]
  not: ModelAccountReadModelFilterInput
}

input CreateAccountReadModelInput {
  id: ID
  aggregateId: ID!
  version: Int!
  userId: ID!
  name: String!
  description: String
  bookValue: Float!
  marketValue: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  accountReadModelAccountTypeId: ID!
}

input UpdateAccountReadModelInput {
  id: ID!
  aggregateId: ID
  version: Int
  userId: ID
  name: String
  description: String
  bookValue: Float
  marketValue: Float
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  accountReadModelAccountTypeId: ID
}

input DeleteAccountReadModelInput {
  id: ID
}

input ModelAccountReadModelConditionInput {
  aggregateId: ModelIDInput
  version: ModelIntInput
  userId: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  bookValue: ModelFloatInput
  marketValue: ModelFloatInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelAccountReadModelConditionInput]
  or: [ModelAccountReadModelConditionInput]
  not: ModelAccountReadModelConditionInput
}

type ModelTransactionReadModelConnection {
  items: [TransactionReadModel]
  nextToken: String
}

input ModelTransactionReadModelFilterInput {
  id: ModelIDInput
  aggregateId: ModelIDInput
  version: ModelIntInput
  userId: ModelIDInput
  transactionDate: ModelStringInput
  shares: ModelIntInput
  price: ModelFloatInput
  commission: ModelFloatInput
  symbol: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTransactionReadModelFilterInput]
  or: [ModelTransactionReadModelFilterInput]
  not: ModelTransactionReadModelFilterInput
}

input CreateTransactionReadModelInput {
  id: ID
  aggregateId: ID!
  version: Int!
  userId: ID!
  transactionDate: AWSDate!
  shares: Int!
  price: Float!
  commission: Float!
  symbol: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  transactionReadModelAccountId: ID!
  transactionReadModelTransactionTypeId: ID!
}

input UpdateTransactionReadModelInput {
  id: ID!
  aggregateId: ID
  version: Int
  userId: ID
  transactionDate: AWSDate
  shares: Int
  price: Float
  commission: Float
  symbol: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  transactionReadModelAccountId: ID
  transactionReadModelTransactionTypeId: ID
}

input DeleteTransactionReadModelInput {
  id: ID
}

input ModelTransactionReadModelConditionInput {
  aggregateId: ModelIDInput
  version: ModelIntInput
  userId: ModelIDInput
  transactionDate: ModelStringInput
  shares: ModelIntInput
  price: ModelFloatInput
  commission: ModelFloatInput
  symbol: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelTransactionReadModelConditionInput]
  or: [ModelTransactionReadModelConditionInput]
  not: ModelTransactionReadModelConditionInput
}

type ModelPositionReadModelConnection {
  items: [PositionReadModel]
  nextToken: String
}

input ModelPositionReadModelFilterInput {
  id: ModelIDInput
  aggregateId: ModelIDInput
  version: ModelIntInput
  userId: ModelIDInput
  symbol: ModelStringInput
  name: ModelStringInput
  shares: ModelIntInput
  acb: ModelFloatInput
  bookValue: ModelFloatInput
  marketValue: ModelFloatInput
  type: ModelStringInput
  region: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPositionReadModelFilterInput]
  or: [ModelPositionReadModelFilterInput]
  not: ModelPositionReadModelFilterInput
}

input CreatePositionReadModelInput {
  id: ID
  aggregateId: ID!
  version: Int!
  userId: ID!
  symbol: String!
  name: String!
  shares: Int!
  acb: Float!
  bookValue: Float!
  marketValue: Float!
  type: String!
  region: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  positionReadModelAccountId: ID!
}

input UpdatePositionReadModelInput {
  id: ID!
  aggregateId: ID
  version: Int
  userId: ID
  symbol: String
  name: String
  shares: Int
  acb: Float
  bookValue: Float
  marketValue: Float
  type: String
  region: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  positionReadModelAccountId: ID
}

input DeletePositionReadModelInput {
  id: ID
}

input ModelPositionReadModelConditionInput {
  aggregateId: ModelIDInput
  version: ModelIntInput
  userId: ModelIDInput
  symbol: ModelStringInput
  name: ModelStringInput
  shares: ModelIntInput
  acb: ModelFloatInput
  bookValue: ModelFloatInput
  marketValue: ModelFloatInput
  type: ModelStringInput
  region: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPositionReadModelConditionInput]
  or: [ModelPositionReadModelConditionInput]
  not: ModelPositionReadModelConditionInput
}

type ModelTimeSeriesConnection {
  items: [TimeSeries]
  nextToken: String
}

input ModelTimeSeriesFilterInput {
  id: ModelIDInput
  symbol: ModelStringInput
  name: ModelStringInput
  type: ModelStringInput
  region: ModelStringInput
  currency: ModelStringInput
  date: ModelStringInput
  open: ModelFloatInput
  high: ModelFloatInput
  low: ModelFloatInput
  close: ModelFloatInput
  volume: ModelIntInput
  and: [ModelTimeSeriesFilterInput]
  or: [ModelTimeSeriesFilterInput]
  not: ModelTimeSeriesFilterInput
}

input CreateTimeSeriesInput {
  id: ID
  symbol: String!
  name: String!
  type: String!
  region: String!
  currency: String!
  date: AWSDate!
  open: Float!
  high: Float!
  low: Float!
  close: Float!
  volume: Int!
}

input UpdateTimeSeriesInput {
  id: ID!
  symbol: String
  name: String
  type: String
  region: String
  currency: String
  date: AWSDate
  open: Float
  high: Float
  low: Float
  close: Float
  volume: Int
}

input DeleteTimeSeriesInput {
  id: ID
}

input ModelTimeSeriesConditionInput {
  symbol: ModelStringInput
  name: ModelStringInput
  type: ModelStringInput
  region: ModelStringInput
  currency: ModelStringInput
  date: ModelStringInput
  open: ModelFloatInput
  high: ModelFloatInput
  low: ModelFloatInput
  close: ModelFloatInput
  volume: ModelIntInput
  and: [ModelTimeSeriesConditionInput]
  or: [ModelTimeSeriesConditionInput]
  not: ModelTimeSeriesConditionInput
}
