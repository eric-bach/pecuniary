# Event Store
type Event @model @aws_api_key @aws_cognito_user_pools {
  id: ID!
  aggregateId: ID!
  name: String!
  version: Int!
  data: String!
  userId: ID!
  createdAt: AWSDateTime!
}

# Lookup Types
type AccountType @model @aws_api_key @aws_cognito_user_pools {
  id: ID!
  name: String!
  description: String
  accounts: [AccountReadModel]! @connection(name: "AccountType")
}

type TransactionType @model {
  id: ID!
  name: String!
  description: String!
  transactions: [TransactionReadModel] @connection(name: "TransactionTypes")
}

type CurrencyType @model {
  id: ID!
  name: String!
  description: String!
  exchangeTypes: [ExchangeType]! @connection(name: "ExchangeCurrencyTypes")
}

type ExchangeType @model {
  id: ID!
  name: String!
  description: String!
  currencyType: CurrencyType! @connection(name: "ExchangeCurrencyTypes")
}

# Read Store
type AccountReadModel @model @aws_api_key @aws_cognito_user_pools {
  id: ID!
  aggregateId: ID!
  version: Int!
  userId: ID!
  name: String!
  description: String
  bookValue: Float!
  marketValue: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  accountType: AccountType! @connection(name: "AccountType")
  transactions: [TransactionReadModel] @connection(name: "Transactions")
  positions: [PositionReadModel] @connection(name: "Positions")
}

type TransactionReadModel @model @aws_api_key @aws_cognito_user_pools {
  id: ID!
  aggregateId: ID!
  version: Int!
  userId: ID!
  transactionDate: AWSDate!
  shares: Int!
  price: Float!
  commission: Float!
  symbol: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  account: AccountReadModel! @connection(name: "Transactions")
  transactionType: TransactionType! @connection(name: "TransactionTypes")
  transactionReadModelAccountId: ID!
}

type PositionReadModel @model @aws_api_key @aws_cognito_user_pools {
  id: ID!
  aggregateId: ID!
  version: Int!
  userId: ID!
  symbol: String!
  name: String!
  description: String!
  exchange: String!
  currency: String!
  country: String!
  shares: Int!
  acb: Float!
  bookValue: Float!
  marketValue: Float!
  lastTransactionDate: AWSDate
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  account: AccountReadModel! @connection(name: "Positions")
  positionReadModelAccountId: ID!
}

type TimeSeries @model @aws_api_key {
  id: ID!
  symbol: String!
  date: AWSDate!
  open: Float!
  high: Float!
  low: Float!
  close: Float!
  adjusted_close: Float!
  volume: Int!
  split_coefficient: Float!
}

# Enums
enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}
input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}
input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}
input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}
input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

type ModelEventConnection @aws_api_key @aws_cognito_user_pools {
  items: [Event]
  nextToken: String
}

input ModelEventFilterInput {
  id: ModelIDInput
  aggregateId: ModelIDInput
  name: ModelStringInput
  version: ModelIntInput
  data: ModelStringInput
  userId: ModelIDInput
  createdAt: ModelStringInput
  and: [ModelEventFilterInput]
  or: [ModelEventFilterInput]
  not: ModelEventFilterInput
}

type Query {
  listEvents(filter: ModelEventFilterInput, limit: Int, nextToken: String): ModelEventConnection
    @aws_api_key
    @aws_cognito_user_pools(cognito_groups: ["Users"])
  getAccountsByUser(userId: String!): [AccountReadModel] @aws_cognito_user_pools(cognito_groups: ["Users"])
}

input CreateEventInput {
  id: ID
  aggregateId: ID!
  name: String!
  version: Int!
  data: String!
  userId: ID!
  createdAt: AWSDateTime
}

type Mutation {
  createEvent(event: CreateEventInput!): Event @aws_cognito_user_pools(cognito_groups: ["Users"])
}

type Subscription {
  onCreateEvent: Event @aws_subscribe(mutations: ["createEvent"])
}
